<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TENG 圖片處理工具 v1.7</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/heic2any@0.0.4/dist/heic2any.min.js"></script>
    <script src="https://unpkg.com/jszip@3.10.1/dist/jszip.min.js"></script>
    <script src="https://unpkg.com/file-saver@2.0.5/dist/FileSaver.min.js"></script>
    <style>
        /* 與 v1.6 相同，省略以節省空間 */
    </style>
</head>
<body>
    <div class="container">
        <h1>TENG 圖片處理工具 v1.7</h1>
        <!-- 其餘 HTML 與 v1.6 相同，省略以節省空間 -->
    </div>

    <script>
        let originalImages = [];
        let processedBlobs = [];
        let base64Data = [];
        let downloadBlob = null;
        let downloadFileName = '';
        let currentDimensionMode = 'width';
        let currentWidthValue = '1024';
        let currentHeightValue = '1024';
        let currentQualityValue = '0.9';
        let currentFormatValue = 'image/jpeg';

        // 防抖函數
        function debounce(func, wait) {
            let timeout;
            return function (...args) {
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(this, args), wait);
            };
        }

        // 初始化模式
        switchMode('resize');

        // 模式切換
        function switchMode(mode) {
            document.querySelectorAll('.mode-button').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.mode === mode);
            });
            document.querySelectorAll('.mode-specific').forEach(el => {
                el.style.display = el.dataset.mode === mode ? 'block' : 'none';
            });
            currentFormatValue = mode === 'resize' ? 'image/jpeg' : 'image/png';
            document.querySelectorAll('.format-button').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.value === currentFormatValue);
            });
            toggleQualityContainer();
            clearFiles();
            if (mode === 'resize') {
                switchDimensionMode(currentDimensionMode);
            }
        }

        // 尺寸模式切換
        function switchDimensionMode(mode) {
            currentDimensionMode = mode;
            document.querySelectorAll('.dimension-button').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.mode === mode);
            });
            // 根據模式顯示/隱藏寬度與高度選單
            document.getElementById('widthContainer').classList.toggle('hidden', mode === 'height');
            document.getElementById('heightContainer').classList.toggle('hidden', mode === 'width');
            updateDimensionInputs();
            updateFileList();
        }

        // 設置寬度或高度值
        function setSize(type, value) {
            const buttons = document.querySelectorAll(`#${type}Container .size-button`);
            buttons.forEach(btn => {
                btn.classList.toggle('active', btn.dataset.value === value);
            });
            const input = document.getElementById(`${type}Input`);
            input.classList.toggle('hidden', value !== 'custom');
            if (type === 'width') {
                currentWidthValue = value;
            } else {
                currentHeightValue = value;
            }
            updateDimensions();
            updateFileList();
        }

        // 設置品質值
        function setQuality(value) {
            document.querySelectorAll('.quality-button').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.value === value);
            });
            const input = document.getElementById('qualityInput');
            input.classList.toggle('hidden', value !== 'custom');
            currentQualityValue = value;
            updateFileList();
        }

        // 設置輸出格式
        function setFormat(value) {
            document.querySelectorAll('.format-button').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.value === value);
            });
            currentFormatValue = value;
            toggleQualityContainer();
            updateFileList();
        }

        // 清空檔案
        function clearFiles() {
            originalImages = [];
            processedBlobs = [];
            base64Data = [];
            document.getElementById('fileList').innerHTML = '';
            document.getElementById('previewContainer').innerHTML = '';
            document.getElementById('base64OutputContainer').innerHTML = '';
            document.getElementById('base64Text').value = '';
            document.getElementById('downloadButton').style.display = 'none';
            document.getElementById('progressContainer').style.display = 'none';
            currentWidthValue = '1024';
            currentHeightValue = '1024';
            currentQualityValue = '0.9';
            document.querySelectorAll('.size-button').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.value === '1024');
            });
            document.querySelectorAll('.quality-button').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.value === '0.9');
            });
            document.getElementById('widthInput').classList.add('hidden');
            document.getElementById('heightInput').classList.add('hidden');
            document.getElementById('qualityInput').classList.add('hidden');
            document.querySelectorAll('.format-button').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.value === currentFormatValue);
            });
            updateFileList();
        }

        // 顯示錯誤訊息
        function showError(message) {
            const errorDiv = document.getElementById('errorMessage');
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
            setTimeout(() => {
                errorDiv.style.display = 'none';
            }, 3000);
        }

        // 處理檔案輸入
        document.getElementById('imageInput').addEventListener('change', e => handleFileSelect(e, true, 'image'));
        document.getElementById('folderInput').addEventListener('change', e => handleFileSelect(e, true, 'image'));
        document.getElementById('base64Input').addEventListener('change', e => handleFileSelect(e, true, 'base64'));

        // 下載按鈕
        document.getElementById('downloadButton').addEventListener('click', () => {
            if (downloadBlob && downloadFileName) {
                saveAs(downloadBlob, downloadFileName);
            }
        });

        function handleFileSelect(e, append = false, type = 'image') {
            const files = e.target.files;
            if (!files || files.length === 0) return;

            if (!append) {
                clearFiles();
            }

            Array.from(files).forEach((file, index) => {
                if (originalImages.some(img => img.file.name === file.name && img.file.size === file.size)) {
                    showError(`檔案 ${file.name} 已存在，請選擇其他檔案！`);
                    return;
                }

                if (type === 'image') {
                    const isHeicHeif = file.name.toLowerCase().endsWith('.heic') || file.name.toLowerCase().endsWith('.heif');
                    if (isHeicHeif) {
                        heic2any({ blob: file, toType: 'image/png' })
                            .then(result => {
                                const reader = new FileReader();
                                reader.onload = function(e) {
                                    handleImageLoad(file, e.target.result, originalImages.length, 'image');
                                };
                                reader.readAsDataURL(result);
                            })
                            .catch(err => {
                                showError(`HEIC/HEIF 轉換失敗 (${file.name})：${err.message}`);
                                const reader = new FileReader();
                                reader.onload = function(e) {
                                    handleImageLoad(file, e.target.result, originalImages.length, 'image');
                                };
                                reader.readAsDataURL(file);
                            });
                    } else {
                        const reader = new FileReader();
                        reader.onload = function(e) {
                            handleImageLoad(file, e.target.result, originalImages.length, 'image');
                        };
                        reader.readAsDataURL(file);
                    }
                } else if (type === 'base64') {
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        handleBase64FileLoad(file, e.target.result, originalImages.length);
                    };
                    reader.readAsText(file);
                }
            });
        }

        function handleImageLoad(file, imageSrc, index, type) {
            const img = new Image();
            img.onload = function() {
                originalImages.push({ file, img, type, base64: type === 'image' ? imageSrc : null });
                updateFileList();
                const thumbnail = document.createElement('img');
                thumbnail.src = imageSrc;
                thumbnail.className = 'thumbnail';
                thumbnail.dataset.index = index;
                thumbnail.title = file.name;
                document.getElementById('previewContainer').appendChild(thumbnail);
                if (document.querySelector('.mode-button.active').dataset.mode === 'resize') {
                    updateDimensionInputs();
                }
            };
            img.onerror = function() {
                showError(`無法載入圖片：${file.name}，請確認檔案格式是否為 JPEG、PNG、HEIC 或 HEIF！`);
            };
            img.src = imageSrc;
        }

        async function handleBase64FileLoad(file, text, index) {
            let base64String = text.trim();
            const prefixes = [
                'data:image/jpeg;base64,',
                'data:image/png;base64,',
                'data:image/webp;base64,'
            ];

            if (base64String.startsWith('data:image/')) {
                tryImageLoad(file, base64String, index);
                return;
            }

            for (let prefix of prefixes) {
                const testString = prefix + base64String;
                const isValid = await tryImageLoad(file, testString, index, false);
                if (isValid) {
                    originalImages.push({ file, img: new Image(), type: 'base64', base64: testString });
                    updateFileList();
                    const thumbnail = document.createElement('img');
                    thumbnail.src = testString;
                    thumbnail.className = 'thumbnail';
                    thumbnail.dataset.index = index;
                    thumbnail.title = file.name;
                    document.getElementById('previewContainer').appendChild(thumbnail);
                    return;
                }
            }

            showError(`無法載入 Base64 檔案：${file.name}，請確認內容是否為有效的圖片 Base64 字串！`);
        }

        async function tryImageLoad(file, base64String, index, addToImages = true) {
            return new Promise((resolve) => {
                const img = new Image();
                img.onload = function() {
                    if (addToImages) {
                        originalImages.push({ file, img, type: 'base64', base64: base64String });
                        updateFileList();
                        const thumbnail = document.createElement('img');
                        thumbnail.src = base64String;
                        thumbnail.className = 'thumbnail';
                        thumbnail.dataset.index = index;
                        thumbnail.title = file.name;
                        document.getElementById('previewContainer').appendChild(thumbnail);
                    }
                    resolve(true);
                };
                img.onerror = function() {
                    resolve(false);
                };
                img.src = base64String;
            });
        }

        function updateFileList() {
            const fileList = document.getElementById('fileList');
            fileList.innerHTML = '';
            const mode = document.querySelector('.mode-button.active').dataset.mode;
            document.getElementById('fileListHeader').textContent = `已選擇的檔案：${originalImages.length} 張`;

            originalImages.forEach((item, index) => {
                const listItem = document.createElement('div');
                listItem.className = 'file-item';
                let text = `${item.file.name} (${item.type === 'image' ? '圖片' : 'Base64'})`;
                if (mode === 'resize' && item.type === 'image') {
                    const widthInput = parseInt(document.getElementById('widthInput').value) || item.img.width;
                    const heightInput = parseInt(document.getElementById('heightInput').value) || item.img.height;
                    const dimensionMode = currentDimensionMode;
                    const aspectRatio = document.getElementById('aspectRatio').checked;

                    let width = dimensionMode !== 'height' && currentWidthValue === 'custom' ? widthInput : parseInt(currentWidthValue);
                    let height = dimensionMode !== 'width' && currentHeightValue === 'custom' ? heightInput : parseInt(currentHeightValue);

                    if (aspectRatio) {
                        const ratio = item.img.height / item.img.width;
                        if (dimensionMode === 'width' && currentWidthValue !== '') {
                            height = Math.round(width * ratio);
                        } else if (dimensionMode === 'height' && currentHeightValue !== '') {
                            width = Math.round(height / ratio);
                        } else if (dimensionMode === 'both' && currentWidthValue !== '' && currentHeightValue !== '') {
                            height = Math.round(width * ratio);
                        } else if (!widthInput && !heightInput) {
                            width = item.img.width;
                            height = item.img.height;
                        }
                    } else if (dimensionMode === 'width') {
                        height = item.img.height;
                    } else if (dimensionMode === 'height') {
                        width = item.img.width;
                    }

                    text += ` | 原尺寸: ${item.img.width}x${item.img.height}`;
                    if (width && height) {
                        text += ` | 調整後: ${width}x${height}`;
                    }
                }
                listItem.textContent = text;
                fileList.appendChild(listItem);
            });
        }

        function toggleQualityContainer() {
            const qualityContainer = document.getElementById('qualityContainer');
            qualityContainer.style.display = currentFormatValue === 'image/png' ? 'none' : 'block';
            updateFileList();
        }

        function updateDimensionInputs() {
            if (!originalImages[0]) return;
            const width = originalImages[0].img.width;
            const height = originalImages[0].img.height;
            const options = ['256', '512', '1024', '1280'];
            currentWidthValue = options.includes(width.toString()) ? width.toString() : '1024';
            currentHeightValue = options.includes(height.toString()) ? height.toString() : '1024';
            document.querySelectorAll('#widthContainer .size-button').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.value === currentWidthValue);
            });
            document.querySelectorAll('#heightContainer .size-button').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.value === currentHeightValue);
            });
            document.getElementById('widthInput').classList.toggle('hidden', currentWidthValue !== 'custom');
            document.getElementById('heightInput').classList.toggle('hidden', currentHeightValue !== 'custom');
            updateDimensions();
        }

        function updateDimensions() {
            if (!originalImages[0]) return;

            const widthInput = parseInt(document.getElementById('widthInput').value) || originalImages[0].img.width;
            const heightInput = parseInt(document.getElementById('heightInput').value) || originalImages[0].img.height;
            const aspectRatio = document.getElementById('aspectRatio').checked;

            let width = currentWidthValue === 'custom' ? widthInput : parseInt(currentWidthValue);
            let height = currentHeightValue === 'custom' ? heightInput : parseInt(currentHeightValue);

            if (aspectRatio) {
                const ratio = originalImages[0].img.height / originalImages[0].img.width;
                if (currentDimensionMode === 'width' && width > 0) {
                    currentHeightValue = 'custom';
                    document.getElementById('heightInput').value = Math.round(width * ratio);
                    document.querySelectorAll('#heightContainer .size-button').forEach(btn => {
                        btn.classList.toggle('active', btn.dataset.value === 'custom');
                    });
                    document.getElementById('heightInput').classList.remove('hidden');
                } else if (currentDimensionMode === 'height' && height > 0) {
                    currentWidthValue = 'custom';
                    document.getElementById('widthInput').value = Math.round(height / ratio);
                    document.querySelectorAll('#widthContainer .size-button').forEach(btn => {
                        btn.classList.toggle('active', btn.dataset.value === 'custom');
                    });
                    document.getElementById('widthInput').classList.remove('hidden');
                } else if (currentDimensionMode === 'both') {
                    if (width > 0) {
                        currentHeightValue = 'custom';
                        document.getElementById('heightInput').value = Math.round(width * ratio);
                        document.querySelectorAll('#heightContainer .size-button').forEach(btn => {
                            btn.classList.toggle('active', btn.dataset.value === 'custom');
                        });
                        document.getElementById('heightInput').classList.remove('hidden');
                    } else if (height > 0) {
                        currentWidthValue = 'custom';
                        document.getElementById('widthInput').value = Math.round(height / ratio);
                        document.querySelectorAll('#widthContainer .size-button').forEach(btn => {
                            btn.classList.toggle('active', btn.dataset.value === 'custom');
                        });
                        document.getElementById('widthInput').classList.remove('hidden');
                    }
                }
            }
            updateFileList();
        }

        // 防抖處理輸入框
        const debouncedUpdateDimensions = debounce(updateDimensions, 300);
        document.getElementById('widthInput').addEventListener('input', debouncedUpdateDimensions);
        document.getElementById('heightInput').addEventListener('input', debouncedUpdateDimensions);
        document.getElementById('qualityInput').addEventListener('input', updateFileList);
        document.getElementById('aspectRatio').addEventListener('change', updateDimensions);

        function updateProgress(current, total) {
            const progressContainer = document.getElementById('progressContainer');
            const progressFill = document.getElementById('progressFill');
            const progressText = document.getElementById('progressText');
            progressContainer.style.display = total > 1 ? 'block' : 'none';
            const percentage = (current / total) * 100;
            progressFill.style.width = `${percentage}%`;
            progressText.textContent = `處理中：${current}/${total}`;
        }

        async function processResize() {
            if (originalImages.length === 0 || !originalImages.some(item => item.type === 'image')) {
                showError('請先選擇圖片檔案！');
                return;
            }

            const format = currentFormatValue;
            const widthInput = parseInt(document.getElementById('widthInput').value);
            const heightInput = parseInt(document.getElementById('heightInput').value);
            const aspectRatio = document.getElementById('aspectRatio').checked;
            const qualityInput = parseInt(document.getElementById('qualityInput').value);
            const quality = currentQualityValue === 'custom' ? (qualityInput / 100) || 0.9 : parseFloat(currentQualityValue);

            const zip = new JSZip();
            processedBlobs = [];
            document.getElementById('previewContainer').innerHTML = '';
            const totalImages = originalImages.filter(item => item.type === 'image').length;
            let processedCount = 0;

            for (let i = 0; i < originalImages.length; i++) {
                const item = originalImages[i];
                if (item.type !== 'image') continue;

                processedCount++;
                updateProgress(processedCount, totalImages);

                const img = item.img;
                const canvas = document.createElement('canvas');
                let width = currentWidthValue === 'custom' ? (widthInput || img.width) : parseInt(currentWidthValue);
                let height = currentHeightValue === 'custom' ? (heightInput || img.height) : parseInt(currentHeightValue);

                if (aspectRatio) {
                    const ratio = img.height / img.width;
                    if (currentDimensionMode === 'width' && currentWidthValue !== '') {
                        height = Math.round(width * ratio);
                    } else if (currentDimensionMode === 'height' && currentHeightValue !== '') {
                        width = Math.round(height / ratio);
                    } else if (currentDimensionMode === 'both' && currentWidthValue !== '' && currentHeightValue !== '') {
                        height = Math.round(width * ratio);
                    } else if (!widthInput && !heightInput) {
                        width = img.width;
                        height = img.height;
                    }
                } else if (currentDimensionMode === 'width') {
                    height = img.height;
                } else if (currentDimensionMode === 'height') {
                    width = img.width;
                }

                canvas.width = width;
                canvas.height = height;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0, width, height);

                try {
                    const blob = await new Promise(resolve => canvas.toBlob(resolve, format, format === 'image/png' ? 1.0 : quality));
                    const originalName = item.file.name.split('.').slice(0, -1).join('.');
                    const extension = format.split('/')[1];
                    const newFileName = `${originalName}_${width}x${height}.${extension}`;
                    processedBlobs.push({ blob, name: newFileName });

                    if (totalImages > 1) {
                        zip.file(newFileName, blob);
                    }

                    const thumbnail = document.createElement('img');
                    thumbnail.src = URL.createObjectURL(blob);
                    thumbnail.className = 'thumbnail';
                    thumbnail.dataset.index = i;
                    thumbnail.title = newFileName;
                    document.getElementById('previewContainer').appendChild(thumbnail);
                } catch (err) {
                    showError(`處理圖片 ${item.file.name} 失敗：${err.message}`);
                }
            }

            document.getElementById('progressContainer').style.display = 'none';
            const downloadButton = document.getElementById('downloadButton');
            downloadButton.style.display = 'block';

            if (totalImages === 1) {
                downloadBlob = processedBlobs[0].blob;
                downloadFileName = processedBlobs[0].name;
                downloadButton.textContent = '下載處理後的圖片';
            } else {
                try {
                    downloadBlob = await zip.generateAsync({ type: 'blob' });
                    downloadFileName = 'processed_images.zip';
                    downloadButton.textContent = '下載 ZIP 壓縮檔';
                } catch (err) {
                    showError(`生成 ZIP 檔案失敗：${err.message}`);
                }
            }
        }

        async function processImageToBase64() {
            if (originalImages.length === 0 || !originalImages.some(item => item.type === 'image')) {
                showError('請先選擇圖片檔案！');
                return;
            }

            const zip = new JSZip();
            base64Data = [];
            document.getElementById('base64OutputContainer').innerHTML = '';
            const totalImages = originalImages.filter(item => item.type === 'image').length;
            let processedCount = 0;

            for (let i = 0; i < originalImages.length; i++) {
                const item = originalImages[i];
                if (item.type !== 'image') continue;

                processedCount++;
                updateProgress(processedCount, totalImages);

                const base64String = item.base64;
                base64Data.push({ name: item.file.name, base64: base64String });

                const outputDiv = document.createElement('div');
                outputDiv.className = 'file-item';
                outputDiv.innerHTML = `<strong>${item.file.name}</strong><br><textarea readonly>${base64String}</textarea>`;
                document.getElementById('base64OutputContainer').appendChild(outputDiv);

                if (totalImages > 1) {
                    zip.file(`${item.file.name}.txt`, base64String);
                }
            }

            document.getElementById('progressContainer').style.display = 'none';
            const downloadButton = document.getElementById('downloadButton');
            downloadButton.style.display = 'block';

            if (totalImages === 1) {
                const { base64, name } = base64Data[0];
                downloadBlob = new Blob([base64], { type: 'text/plain' });
                downloadFileName = `${name}.txt`;
                downloadButton.textContent = '下載 Base64 檔案';
            } else {
                try {
                    downloadBlob = await zip.generateAsync({ type: 'blob' });
                    downloadFileName = 'base64_files.zip';
                    downloadButton.textContent = '下載 Base64 ZIP 壓縮檔';
                } catch (err) {
                    showError(`生成 Base64 ZIP 檔案失敗：${err.message}`);
                }
            }
        }

        async function processBase64ToImage() {
            let base64String = document.getElementById('base64Text').value.trim();
            const format = currentFormatValue;
            const qualityInput = parseInt(document.getElementById('qualityInput').value);
            const quality = currentQualityValue === 'custom' ? (qualityInput / 100) || 0.9 : parseFloat(currentQualityValue);
            const base64Files = originalImages.filter(item => item.type === 'base64');
            const prefixes = [
                'data:image/jpeg;base64,',
                'data:image/png;base64,',
                'data:image/webp;base64,'
            ];

            if (!base64String && base64Files.length === 0) {
                showError('請輸入 Base64 字串或選擇 Base64 檔案！');
                return;
            }

            const zip = new JSZip();
            processedBlobs = [];
            document.getElementById('previewContainer').innerHTML = '';
            const totalItems = (base64String ? 1 : 0) + base64Files.length;
            let processedCount = 0;

            if (base64String) {
                processedCount++;
                updateProgress(processedCount, totalItems);

                let validBase64 = base64String;
                if (!base64String.startsWith('data:image/')) {
                    for (let prefix of prefixes) {
                        const testString = prefix + base64String;
                        const isValid = await tryImageLoad(null, testString, 0, false);
                        if (isValid) {
                            validBase64 = testString;
                            break;
                        }
                    }
                }

                try {
                    const img = new Image();
                    img.onload = async function() {
                        const canvas = document.createElement('canvas');
                        canvas.width = img.width;
                        canvas.height = img.height;
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(img, 0, 0);
                        const blob = await new Promise(resolve => canvas.toBlob(resolve, format, format === 'image/png' ? 1.0 : quality));
                        const fileName = `converted_image_${Date.now()}.${format.split('/')[1]}`;
                        processedBlobs.push({ blob, name: fileName });

                        const thumbnail = document.createElement('img');
                        thumbnail.src = URL.createObjectURL(blob);
                        thumbnail.className = 'thumbnail';
                        thumbnail.title = fileName;
                        document.getElementById('previewContainer').appendChild(thumbnail);

                        if (base64Files.length > 0) {
                            zip.file(fileName, blob);
                        } else {
                            const downloadButton = document.getElementById('downloadButton');
                            downloadButton.style.display = 'block';
                            downloadBlob = blob;
                            downloadFileName = fileName;
                            downloadButton.textContent = '下載轉換後的圖片';
                        }
                        updateProgress(processedCount, totalItems);
                    };
                    img.onerror = function() {
                        showError('無法載入 Base64 字串，請確認是否為有效的圖片 Base64 字串！');
                        updateProgress(processedCount, totalItems);
                    };
                    img.src = validBase64;
                } catch (err) {
                    showError(`Base64 字串轉換失敗：${err.message}`);
                    updateProgress(processedCount, totalItems);
                }
            }

            for (let i = 0; i < base64Files.length; i++) {
                const item = base64Files[i];
                processedCount++;
                updateProgress(processedCount, totalItems);

                try {
                    const img = new Image();
                    img.onload = async function() {
                        const canvas = document.createElement('canvas');
                        canvas.width = img.width;
                        canvas.height = img.height;
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(img, 0, 0);
                        const blob = await new Promise(resolve => canvas.toBlob(resolve, format, format === 'image/png' ? 1.0 : quality));
                        const originalName = item.file.name.split('.').slice(0, -1).join('.');
                        const extension = format.split('/')[1];
                        const newFileName = `${originalName}.${extension}`;
                        processedBlobs.push({ blob, name: newFileName });
                        zip.file(newFileName, blob);

                        const thumbnail = document.createElement('img');
                        thumbnail.src = URL.createObjectURL(blob);
                        thumbnail.className = 'thumbnail';
                        thumbnail.dataset.index = originalImages.indexOf(item);
                        thumbnail.title = newFileName;
                        document.getElementById('previewContainer').appendChild(thumbnail);

                        if (processedCount === totalItems) {
                            try {
                                const zipBlob = await zip.generateAsync({ type: 'blob' });
                                const downloadButton = document.getElementById('downloadButton');
                                downloadButton.style.display = 'block';
                                downloadBlob = zipBlob;
                                downloadFileName = 'converted_images.zip';
                                downloadButton.textContent = '下載轉換後的圖片 ZIP 壓縮檔';
                            } catch (err) {
                                showError(`生成 ZIP 檔案失敗：${err.message}`);
                            }
                        }
                        updateProgress(processedCount, totalItems);
                    };
                    img.onerror = function() {
                        showError(`無法載入 Base64 檔案：${item.file.name}，請確認內容是否為有效的圖片 Base64 字串！`);
                        updateProgress(processedCount, totalItems);
                    };
                    img.src = item.base64;
                } catch (err) {
                    showError(`Base64 檔案轉換失敗：${item.file.name}，錯誤：${err.message}`);
                    updateProgress(processedCount, totalItems);
                }
            }

            document.getElementById('progressContainer').style.display = 'none';
        }
    </script>
</body>
</html>
